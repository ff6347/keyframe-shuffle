// Copyright (c)  2012 // Fabian "fabiantheblind" Morón Zirfas  // Permission is hereby granted, free of charge, to any // person obtaining a copy of this software and associated// documentation files (the "Software"), to deal in the Software// without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense,// and/or sell copies of the Software, and to  permit persons to // whom the Software is furnished to do so, subject to // the following conditions:  // The above copyright notice and this permission notice// shall be included in all copies or substantial portions of the Software.  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  CONTRACT,// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTIO// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  // see also http://www.opensource.org/licenses/mit-license.php{var website = "http://fabiantheblind.info";var version = 0.1;var version_addon = "alpha";var meta = new Object();meta.settings = {    /*      0 = per layer    1 = per prop    2 per key     */    shufflescope : 2,    /*    0 = forward    1= backward    2 = both    */    keytimedir : 0,    range: 0.5};meta.scopetext = function(val){if(val == 0){return "offset per layer";}else if(val == 1){return "offset per property";}else if(val == 2){return "offset per keyframe";}};meta.calc_keytimedir_val = function (boolfwd, boolback){    var val  = null;if((boolback == false)&&(boolfwd == true)){    val  = 0;};if((boolback == true)&&(boolfwd == false)){    val  = 1;};if((boolback == true)&&(boolfwd == true)){    val  = 2;};if((boolback == false)&&(boolfwd == false)){    val  = null;};return val;};/** * Will hold all strings used in the user interface * @type {Object} */meta.uiStrings = {    scriptName : "keyframe-shuffle"};meta.errorStrings = {    noComp:"Please select a composition.",    noKeytimedir:"You need to define a direction"    // noBuzzgenFile : "The 'buzz-gen.json' file is missing. Go to " +     // website + " and download the latest version of "+ meta.uiStrings.scriptName};run_scipt(this);function run_scipt(thisObj){/** * First we have to do some legal stuff * go to the end of the script to se the dialog * */// var res = null;// var settingsSectionName = "swissd";// if((app.settings.haveSetting(settingsSectionName,"licaccept") == true)){// var licres = parseInt(app.settings.getSetting(settingsSectionName,"licaccept"));// if (licres==1){//     res = [true,true];// } else {//     res = licenseDiag("swissd","http://fabiantheblind.info");//     };// }else{//   res = licenseDiag("swissd","http://fabiantheblind.info");// };// if (!res[1]){//     return;// }if(res[0]){//     app.settings.saveSetting(settingsSectionName,"licaccept",1);// };///   THIS WILL CHECK IF PANEL IS DOCKABLE OR FLAOTING WINDOW     var win   = buildUI(thisObj);   if ((win != null) && (win instanceof Window)) {      win.center();      win.show();      }; // end if win  null and not a instance of window };function buildUI(thisObj) {var win = (thisObj instanceof Panel)  ? thisObj : new Window('palette', 'Script Window',[0,57,140,179],{resizeable: true}); if (win != null) { var H = 20;var W = 120;var G = 3;var x = 5;var y = 5;// var itemw1 = 50;win.stxt_off = win.add('statictext', [x,y,W/2,H], 'offset:'); win.stxt_off.justify = 'left';x = x + (W/2) + G;win.etxt_off = win.add('edittext', [x,y,W,H], '0.5'); win.etxt_off.justify = 'left'; x = 5;y = y + H + G;win.radiogrp = win.add('panel',[x,y,W,y + H * 3],''/*, {borderStyle: 'none'} */);xp = G;yp = G;win.radio_one = win.radiogrp.add('radiobutton',[xp,yp,W/3,H], '');// yp = yp + H + G;xp = xp + W/3 + G;win.radio_two = win.radiogrp.add('radiobutton',[xp ,yp,xp + W/3, H], '');xp = xp + W/3 + G;// yp = yp + H + G;win.radio_three = win.radiogrp.add('radiobutton',[xp ,yp,xp + W/3,H], '');xp = G;yp = yp + H + G;win.stxt_scope = win.radiogrp.add('statictext',[xp,yp,W,yp + H], meta.scopetext(meta.settings.shufflescope));xp = G;yp = yp + H + G;win.radio_one.value = false;win.radio_two.value = false;win.radio_three.value = true;x = 5;y = y + (H * 3);win.check_back = win.add('checkbox',[x,y, x +(W/2) ,y+ H],'<<<');x= x + (W/2) + G;win.check_ffwd = win.add('checkbox',[x,y, x + (W/2) ,y + H],'>>>');x = 5;y = y + H + G;win.button_run = win.add('button', [x,y,W,y + H], 'shuffle');win.button_run.onClick = function () {    if(meta.settings.keytimedir != null){        shuffle_keys(meta)    }else{    alert(meta.errorStrings.noKeytimedir);    };};win.etxt_off.onChange = function (){    meta.settings.range = constrainAndParseTextToNumber(this.text, 'Sry this is not a number', null, null,0.5);    this.text = meta.settings.range;};win.radio_one.onClick = function () {    if (this.value == true) {        meta.settings.shufflescope = 0;        win.stxt_scope.text = meta.scopetext(0);    };};win.radio_two.onClick = function () {    if (this.value == true) {        meta.settings.shufflescope = 1;                win.stxt_scope.text = meta.scopetext(1);    };};win.radio_three.onClick = function () {    if (this.value == true) {        meta.settings.shufflescope = 2;                win.stxt_scope.text = meta.scopetext(2);    };};win.check_back.onClick = function(){    meta.settings.keytimedir = meta.calc_keytimedir_val(win.check_ffwd.value,this.value);};win.check_ffwd.onClick = function(){    meta.settings.keytimedir = meta.calc_keytimedir_val(this.value,win.check_back.value);};}return win };// shuffle_keys (meta);function shuffle_keys(meta){    app.beginUndoGroup("shuffle keys");// alert(meta.toSource());// meta.settings.range = parseFloat(prompt("Enter a range in seconds to shuffle", "0.5",""));var curComp = app.project.activeItem;   if (!curComp || !(curComp instanceof CompItem)){        alert(meta.errorStrings.noComp);        return;    };//~ var fdur  = curComp.frameDuration;//~ var shuffle = shuffle_val / fdur;var selLayers =  curComp.selectedLayers;// var shuffle = Math.random() -1; // by half second before and after    var data = new Array();for (var i = 0; i < selLayers.length;i++){        var lyr = selLayers[i];        // theLayers.push(lyr);        var props = new Array();        for(var j = 0; j < lyr.selectedProperties.length; j++){             var prop = lyr.selectedProperties[j];            // layer_sel_props.push(prop);            var propkeys = new Array();            // var keys;            //             for (var k = 0; k < prop.selectedKeys.length;k++){                var keyTime = prop.keyTime(prop.selectedKeys[k]);                var keyValue = prop.keyValue(prop.selectedKeys[k]);                var inTan = null;                var outTan = null;                if(prop.isSpatial == true){                  inTan = prop.keyInSpatialTangent(prop.selectedKeys[k]);                 outTan = prop.keyOutSpatialTangent(prop.selectedKeys[k]);                }                var typeIn = prop.keyInInterpolationType(prop.selectedKeys[k]);                var typeOut = prop.keyOutInterpolationType(prop.selectedKeys[k]);                var keyIndex = prop.selectedKeys[k];                propkeys.push({                    time:keyTime,                    value:keyValue,                    idx: keyIndex,                    inTan:inTan,                    outTan:outTan,                    typeIn: typeIn,                    typeOut: typeOut                    });             };// close K loop             props.push({property: prop, keydata: propkeys});        }; // close J loop        data.push({layer:lyr,properties: props});    }; // close I loop // alert(data[0].layer.name);// for(var l = 0; l < data.length;l++){    // alert(data[l].properties[0].property);    for(var m = 0; m < data[l].properties.length; m++){         // alert(data[l].properties[m].property.name);         for(var n = data[l].properties[m].keydata.length -1; n >= 0; n--){            // alert(data[l].properties[m].keydata[n]);                         var idx = data[l].properties[m].keydata[n].idx;             // alert(idx);             data[l].properties[m].property.removeKey(idx);         }    }}var shuffle = 0;for(var o = 0; o < data.length; o++){    if(meta.settings.shufflescope == 0){    shuffle = calc_shuffle(meta) ;    }    for(var p = 0; p < data[o].properties.length; p ++){     if(meta.settings.shufflescope == 1){    shuffle = calc_shuffle(meta);    }        for(var q = 0; q < data[o].properties[p].keydata.length; q++){            if(meta.settings.shufflescope == 2){            shuffle = calc_shuffle(meta) ;            }                        var new_time = data[o].properties[p].keydata[q].time + shuffle;                        var new_value = data[o].properties[p].keydata[q].value;            // var index = data[o].properties[p].keydata[q].idx;            if(prop.isSpatial == true){             var inTan = data[o].properties[p].keydata[q].inTan;             var outTan = data[o].properties[p].keydata[q].outTan;            }             var typeIn =  data[o].properties[p].keydata[q].typeIn;             var typeOut =  data[o].properties[p].keydata[q].typeOut;            var prop = data[o].properties[p].property;            prop.setValueAtTime(new_time, new_value);            prop.setInterpolationTypeAtKey(prop.nearestKeyIndex(new_time), typeIn, typeOut);            if(prop.isSpatial == true) prop.setSpatialTangentsAtKey(prop.nearestKeyIndex(new_time), inTan, outTan);            prop.setSelectedAtKey(prop.nearestKeyIndex(new_time),true);            // prop.setSpatialTangentsAtKey(index, inTan, outTan);        }    }}    app.endUndoGroup();        }function constrainAndParseTextToNumber(theText, theErrorMessage, minVal, maxVal,resetVal){  var val =  parseFloat (theText);    // if(val > maxVal){    //     val = maxVal;    // };    // if(val < minVal){    //     val = minVal;    // };    val = resetValIfNAN(val,resetVal,theErrorMessage);  return val;};function resetValIfNAN(val,resetVal, theErrorMessage){    if(isNaN (val)==true){    val = resetVal;    alert(theErrorMessage);    };  return val;};function calc_shuffle(meta){    var shuff = 0;    var range = meta.settings.range;    /*    0 = forward    1= backward    2 = both    */       if(meta.settings.keytimedir == 0){        shuff = Math.random() * range;    }else if(meta.settings.keytimedir == 1){        shuff = (Math.random() * range) * -1;    }else if(meta.settings.keytimedir == 2){    shuff = Math.random() * range;    var plusOrMinus = Math.random() < 0.5 ? -1 : 1;    shuff = shuff * plusOrMinus;    }return shuff;};}